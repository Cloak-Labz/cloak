# Pinocchio Withdrawal Proof Verifier

This is a Solana program built with Pinocchio that verifies SP1-generated withdrawal proofs on-chain. It provides zero-knowledge proof verification for token withdrawal authorization from pools.

## Overview

The program verifies:
1. **SP1 Proof Validity**: Verifies the Groth16 proof generated by SP1
2. **User Balance**: Ensures user has sufficient balance for withdrawal
3. **Pool Liquidity**: Confirms pool has enough liquidity
4. **Withdrawal Limits**: Prevents excessive withdrawals (max 50% of pool)
5. **Data Integrity**: Validates all withdrawal parameters

## Program Structure

### Instruction Data Format
The program expects instruction data in the following format (321 bytes total):

```
[0-259]     Groth16 Proof (260 bytes)
[260-271]   SP1 Public Inputs (12 bytes - 3 u32 values)
[260-279]   User Address (20 bytes)
[280-287]   Pool ID (8 bytes)
[288-295]   User Balance (8 bytes)
[296-303]   Withdrawal Amount (8 bytes)
[304-311]   Pool Liquidity (8 bytes)
[312-319]   Timestamp (8 bytes)
[320]       Is Valid (1 byte)
```

### Key Components

- **SP1Groth16WithdrawalProof**: Struct for parsing instruction data
- **process_instruction**: Main program entry point
- **verify_proof**: SP1 proof verification using Groth16
- **On-chain validation**: Additional security checks

## Usage

### Building the Program

```bash
cd pinocchio-withdrawal-proof
cargo build-sbf
```

### Testing

```bash
cargo test-sbf
```

### Integration with SP1

1. Generate an SP1 proof using the withdrawal proof program
2. Extract the Groth16 proof and public inputs
3. Pack the data according to the instruction format
4. Call the Solana program with the packed data

## Security Features

1. **Zero-Knowledge Verification**: Uses SP1's Groth16 proofs
2. **On-chain Validation**: Additional checks beyond SP1 verification
3. **Balance Verification**: Ensures sufficient user funds
4. **Liquidity Checks**: Confirms pool can fulfill withdrawal
5. **Amount Limits**: Prevents excessive withdrawals
6. **Data Integrity**: Validates all parameters

## Example Integration

```rust
// Pack withdrawal proof data
let mut instruction_data = vec![0u8; 321];
instruction_data[0..260].copy_from_slice(&groth16_proof);
instruction_data[260..272].copy_from_slice(&sp1_public_inputs);
instruction_data[260..280].copy_from_slice(&user_address);
instruction_data[280..288].copy_from_slice(&pool_id.to_le_bytes());
instruction_data[288..296].copy_from_slice(&user_balance.to_le_bytes());
instruction_data[296..304].copy_from_slice(&withdrawal_amount.to_le_bytes());
instruction_data[304..312].copy_from_slice(&pool_liquidity.to_le_bytes());
instruction_data[312..320].copy_from_slice(&timestamp.to_le_bytes());
instruction_data[320] = is_valid as u8;

// Call the program
let result = process_instruction(&program_id, &accounts, &instruction_data);
```

## Verification Key

The program uses a verification key hash that must be updated when deploying with a real SP1 program:

```rust
const WITHDRAWAL_PROOF_VKEY_HASH: &str = "0x...";
```

To get the correct hash:
```rust
let client = sp1_sdk::ProverClient::new();
let (pk, vk) = client.setup(WITHDRAWAL_PROOF_ELF);
let vkey_hash = vk.bytes32();
```

## Error Handling

The program returns `ProgramError::InvalidInstructionData` for:
- Invalid instruction data length
- Failed proof verification
- Invalid withdrawal conditions
- Insufficient balance
- Excessive withdrawal amount
- Invalid pool liquidity

## Testing

Run the test suite to verify functionality:

```bash
cargo test-sbf
```

The tests cover:
- Valid withdrawal proofs
- Invalid data formats
- Insufficient balance scenarios
- Excessive withdrawal amounts
- Data structure validation
